import parseTemplateToTokens from './parseTemplateToTokens.js';
import renderTemplate from './renderTemplate.js';
window.TemplateEngine = {
    render(templateStr, data) {
        const tokens = parseTemplateToTokens(templateStr);
        const domStr = renderTemplate(data, tokens);
        return domStr;
    }
};


// 思路一：通过正则获取字符串中的模板，并替换为对应变量名的数据。但是这个方法只适用于简单的数据变量，不适用于多层嵌套的模板。
// 思路二：将模板字符串通过模板标识符切割，并对每个片段类型做出标记，再根据不同标记用不同的方式转换为dom字符串，将所有字符串拼接。
// 1、将模板字符串切割、折叠为一个嵌套数组tokens
//   a.先构造一个扫描器，设置初始值和公共类函数：模板字符串、指针位置、未扫描的字符串、截取两个标识符之间片段的函数、跳过
//     模板标识符的函数、判断是否扫描完毕的函数；
//   b.扫描字符串，根据模板标识符切割，并去空格处理，用text、name、#、/标记不同片段；
//   c.通过栈的概念处理需要循环的片段，设置一个收集器，最初指向结果数组的最外层；设置一个栈，当有需要操作的token时，将其入栈，
//     并将该token的第二个元素设置为空数组，收集器指向这个空数组，保存#和/之间的片段至收集器后，token出栈；收集器重新指向栈中
//     最后入栈的token，重复操作，直至所有token出栈，收集器指向结果数组最外层；
// 2、将tokens结合数据，解析为dom字符串
//   a.token的第一个元素为text时，直接拼接token的第二个元素；
//   b.token的第一个元素为name时，设置一个临时变量，将.符号连接的变量一层一层的从data中获取真实数据，拼接；
//   c.token的第一个元素为#时，先根据第二个元素获取数组数据，循环数组，再按照第二步获取数据拼接；

// 刚开始面对结构简单的模板字符串，我的思路是用正则获取模板，将其替换为变量名对应的数据，但是之后面对多层嵌套的模板，意识到用正则太过复杂。
// 思路二主要分为两大步：一、将模板字符串切割、折叠为一个嵌套数组tokens; 二、将tokens结合数据，解析为dom字符串。
// 以下是思路二的具体步骤：
// 1.构造一个扫描器，设置扫描字符串过程中需要用到的值和方法；比如：设置初始值：模板字符串、指针位置、未扫描的字符串；设置公共函数：
// 截取两个标识符之间片段的函数、跳过模板标识符的函数、判断是否扫描完毕的函数；
// 2.扫描字符串，根据模板标识符切割成若干个片段，对模板标识符之外且不在<>内的片段做去空格处理，对不同类型的片段用text、name、#、
// /标记，每一个片段都是一个token数组，数组的第一个元素是类型标记，第二个元素是处理好的字符串片段;
// 3.#和 / 之间的片段是要根据数据循环的片段，考虑到循环可能多层嵌套，我用到了栈的概念折叠循环片段的tokens。首先设置一个收集器和
// 一个结果数组，收集器最初指向结果数组，收集非#和 / 类型的token；然后设置一个栈，遇到#类型的token，将token入栈，并将该token的
// 第三个元素设置为一个空数组；收集器指向这个空数组，收集至第一个 / 类型的token后，最后入栈的token出栈；收集器指向此刻栈中最后
// 入栈的token，重复前面的收集操作，直至所有token出栈，收集器指向结果数组；
// 4.得到折叠后的tokens，根据token类型结合数据解析：当token的第一个元素为text时，直接拼接token的第二个元素；当token的第一个元素为name时，
// 设置一个临时变量，一层一层地接收.符号连接的变量的真实数据拼接；当token的第一个元素为#时，先根据第二个元素获取数组数据，
// 循环数组，对数组的每一条数据按照这一步的判断获取变量对应的数据拼接；